\section{Oprogramowanie mikrokontrolera}

\subsection{Architektura programu}
\textbf{Po uruchomieniu urządzenia} następuje inicjacja poszczególnych modułów programu, takich jak zegar czasu urzędowego, obsługa liczników czasu, obsługa karty pamięci. Po inicjalizacji jest wykonywany kod dodający zadanie przerysowujące matryce, w~taki sposób, że funkcja \texttt{multiplexCycle} wykonuje się co $200$ $\mu s$. Od tego momentu można wyświetlać treść na ekranie.

\textbf{Funkcja \texttt{multiplexCycle}} wysyła na ekran dane, powodujące wyświetlenie co szesnastej kolumny obrazu, zaczynając od pewnej wartości. Numery tych kolumn można więc wyrazić wzorem $ 16 \times n + k $, gdzie $ n $ przyjmuje wartość od 0 do 7 przy każdym wywołaniu funkcji; $ k $ od 0 do 15, zmieniając się cyklicznie pomiędzy wywołaniami. Wywołanie tej funkcji 16 razy, powoduje przerysowanie całości obrazu. W~funkcji jest wykonywane resetowanie licznika watchdog, ze względu na to, że gdy ta funkcja przestanie się wykonywać, będzie się świeciła co szesnasta kolumna obrazu, 16 razy mocniej niż standardowo, co mogłoby doprowadzić do uszkodzenia matryc z~diodami.

\textbf{Po wyświetleniu napisu powitalnego} następuje wyświetlenie menu. Jest to pętla nieskończona, w~której opcje wyboru stanowią wywołania funkcji \texttt{menuOption} z~podanym napisem, który ma zostać wyświetlony oraz wskaźnikiem na funkcję realizującą daną funkcjonalność. Są to następujące funkcje:

\begin{itemize}
	\item \texttt{printTime} --- funkcja w~pętli przerysowuje zegar, pętla jest przerywana jeżeli dowolny przycisk jest wciśnięty. Użyta została czcionka 0, o~rozmiarze 16 pikseli.
	\item \texttt{printDateTime} --- podobnie jak poprzednia, natomiast czas i~data wyświetlane są w~dwóch liniach, przy użyciu czcionki 1, 8 pikseli; całość jest wyśrodkowana.
	\item \texttt{openFile} --- funkcja otwiera folder \textit{/LEDBOARD} na karcie pamięci i~znajduje w~nim wszystkie pliki M2F i~MXF.~Następnie pozwala wybrać jeden z~tych plików. Jeżeli otwarto plik MXF, wyświetlający się napis jest wsuwany na ekran od prawej strony, poprzez przesuwanie zawartości tablicy i~pobieranie ostatniej kolumny jako odpowiedniej kolumny aktualnie dodawanego znaku. Co znak jest sprawdzany stan przycisków. Jeden z~nich powoduje powrót do menu, drugi zmianę szybkości przesuwania tekstu. Jeżeli otwarto plik M2F, otwarty plik jest przekazywany do funkcji \texttt{openAnimationFile}, która implementuje odtwarzanie takich plików. Została ona opisana poniżej. W~funkcji \texttt{openFile} jest wykorzystana obsługa systemu plików FAT poprzez bibliotekę FatFS.~Otwierane są po kolei: partycja, system plików, folder, pozycja w~folderze, plik. Z~pliku czytane są pojedyncze bajty. Biblioteka zapewnia buforowanie odczytów.
	\item \texttt{setupRTC} --- funkcja służy do ustawiania zegara i~daty. Po kolei, dla poszczególnych wartości, pozwala je ustawić przy użyciu funkcji \texttt{getValue}. Implementuje ona mechanizm, w~którym można szybko zwiększać wartość przez wielokrotne szybkie wciskanie przycisku, bądź przytrzymanie, powodujące coraz szybsze narastanie. Ustawianie sekund jest zaimplementowane w~ten sposób, że po ustawieniu godzin i~minut, zapisanie nowej wartości zeruje liczbę sekund. Przy ustawianiu daty, najpierw jest pobierany rok i~miesiąc, żeby możliwe było określenie jaki jest maksymalny numer dnia w~miesiącu.
	\item \texttt{usbTransfer} --- po uruchomieniu funkcji jest inicjowane złącze USB.~Na ekranie zostaje wyświetlona prosta animacja. Do czasu wciśnięcia dowolnego przycisku ekran jest widoczny dla komputera jako pamięć masowa USB.~Jest to zaimplementowane jako wielokrotne wykonywanie funkcji \texttt{task} z~modułu usbsupprt. Wciśnięcie dowolnego przycisku powoduje deinicjalizację złącza USB.~Spowolnienie animacji oznacza zajęcie urządzenia, czyli operacje wykonywane na karcie pamięci, identyfikację urządzenia i~inne. Teoretycznie złącze USB mogłoby być cały czas aktywne, jednak zastosowane rozwiązanie z~wydzielonym trybem transferu przez USB okazało się rozwiązywać powstałe problemy i~unikać możliwych błędów. Funkcja \texttt{task} powinna być wykonywana często. W~kodzie nie ma jednego takiego miejsca gdzie jest szybko powtarzana pętla. Również dodanie tej funkcji przez \texttt{addTimerJob} okazało się złym rozwiązaniem, ponieważ ta funkcja czasami wykonuje się długo, przez co przerwania wchodziły w~konflikt z~przerysowywaniem ekranu funkcją \texttt{multiplexCycle}, powodując nierównomierność jasności ekranu, widoczne aktualnie przerysowywane piksele. Również w~ten sposób unika się możliwości jednoczesnego zapisu i~odczytu tego samego pliku na karcie.
\end{itemize}

\textbf{Funkcja \texttt{openAnimationFile}} składa się przede wszystkim z~dwóch zagnieżdżonych pętli, zewnętrznej, odpowiadającej kolejnym klatkom, i~wewnętrznej, wczytującej kolejne komendy. Nadrzędna pętla ma się wykonywać co $25$ $ms$, jednak dodanie jej poprzez \texttt{addTimerJob} byłoby złym pomysłem ze względu na konflikty przerwań.~Odmierzanie tego czasu jest więc zrealizowane poprzez synchronizację z~wykonywaniem funkcji \texttt{multiplexCycle}. Co 125 wywołań tamtej funkcji, jest zmieniana wartość pewnej zmiennej globalnej. W~\texttt{openAnimationFile} oczekuje się na takie właśnie zmiany.

\textbf{Tablice opisujące czcionki} znajdują się w~jednym z~plików wykonywalnych. Ze względu na to, że sama czcionka 0, 16 pikseli zawiera prawie $4$ $kB$ danych, nie jest możliwe przechowywanie tych danych w~pamięci operacyjnej. Wykorzystano więc możliwość przechowywania danych tylko do odczytu, w~pamięci programu, przy użyciu makra \texttt{PROGMEM} z~biblioteki AVR Libc \cite{progmem}. Makro działa dzięki temu, że użyty procesor ma zmodyfikowaną architekturę harwardzką.

\textbf{W pamięci przechowywane są 4 bufory obrazu} \texttt{fgnd} i~\texttt{bgnd} zdefiniowane i~używane w~module \texttt{dispfile}, oraz podwójny bufor \texttt{buffers} znajdujący się w~w~module diplay-lowlevel. Bufor \texttt{bgnd} jest używany tylko przy odtwarzaniu plików M2F do przechowywania tła. Tablica \texttt{fgnd} przechowuje aktualny obraz, na nią są nanoszone litery, do niej jest kopiowane tło na początku renderowania klatki przy odtwarzaniu plików M2F.~Obydwie te tablice składają się ze 128 szesnastobitowych elementów (\texttt{uint16\_t}). Każdy z~nich odpowiada jednej kolumnie obrazu, najbardziej znaczący bit odpowiada najniższemu pikselowi. Jako, że przy modyfikacji tablicy \texttt{fgnd} jest ona zazwyczaj najpierw czyszczona, przy zmianach obrazu było widoczne przygasanie obrazu. Dodano więc dodatkowy bufor obrazu, który nie musi być nigdy czyszczony, tylko zawsze jest nadpisywany danymi z~bufora \texttt{fgnd}. Ze względu na to, że sterowanie matrycą wymaga podawania bitów w~zupełnie innej kolejności niż ta w~tablicy \texttt{fgnd}, ten właśnie kolejny bufor jest przechowywany już w~formie przetworzonej. Pojedyncza tablica \texttt{buffers} składa się z~256 elementów (\texttt{uint8\_t}). Zamiana kolejności odpowiednich bitów odbywa się przy kopiowaniu \texttt{fgnd} do \texttt{buffers}. Okazało się jednak, że przetworzenie całej tablicy z~jednego formatu na drugi trwa na tyle długo, że dla szybko przesuwającego się tekstu powstają niekorzystne efekty wizualne. Z~tego względu bufor \texttt{buffers} jest dwuwymiarowy. W~programie jest przechowywany wskaźnik do aktualnej klatki. Konwertowanie \texttt{fgnd} do \texttt{buffers} nanosi dane na niewidoczną część bufora, po czym ustania wskaźnik aktualnej klatki na tę cześć. Jest to implementacja powszechnie wykorzystywanego mechanizmu podwójnego buforowania obrazu.

\subsection{Biblioteki do systemu plików FAT i~funkcjonalności pamięci masowej}
\textbf{Biblioteka LUFA USB Framework} została użyta w~celu implementacji podłączenia USB jako pamięci masowej. Jest ona bardzo popularna, posiada wiele możliwości, między innymi klase urządzeń MassStorage. Wykorzystuje sprzętowy interfejs procesorów AVR.~Obsługa biblioteki jest realizowana poprzez własne funkcje typu callback. Mogą ona obsługiwać takie zdarzenia jak połączenie, odłączenie, rozkazy kontrolne, konfiguracyjne, i~inne. Cykliczne wywoływanie funkcji \texttt{USB\_USBTask} wywołuje te zdarzenia. Przy implementacji skorzystano z~demonstracyjnego kodu implementującego tryb pamięci masowej dołączonego do biblioteki, z~którego skopiowano obsługę klasy mass storage, interpretację rozkazów SCSI.~Bibliotekę podłączono funkcjonalnie do innej, \textit{sd\_raw} służącej do komunikacji z~kartą pamięci SD, czytającą bloki danych z~karty.

\textbf{Biblioteka FatFS} implementuje obsługę systemów plików FAT16 i~FAT32 dla mikrokontrolera. Wymaga ona, podobnie jak LUFA USB Framework, funkcji do czytania i~zapisu bloków danych, dostarczonego przez bibliotekę \textit{sd\_raw}. Projekt sterownika wymaga w~tym przypadku tylko funkcji do odczytu. Dostarczony przez bibliotekę interfejs jest podobny do funkcji wejścia-wyjścia ze standardowej biblioteki języka C.

\subsection{Optymalizacja}

Symulator ekranu napisany w~języku Java generuje zauważalne obciążenie procesora tylko w~związku z~przerysowywaniem widoku ekranu. Obliczenia związane z~nanoszeniem liter na bufor są zupełnie niezauważalne. Odbywały się one poprzez pobieranie poszczególnych pikseli z~czcionek i~wpisywanie pod odpowiedni adres bufora. Po przeniesieniu z~pewnymi zmianami tego kodu do C++ i~uruchomieniu na mikrokontrolerze, okazało się, że nanoszenie czcionek po pikselu jest zbyt kosztowne obliczeniowo dla mikrokontrolera. Już dla pojedynczych liter, było wyraźnie widoczne od której strony są nanoszone. Tym samym okazało się, że konieczne jest wprowadzenie znacznych optymalizacji do kodu.

\subsubsection*{Punkt wyjścia}
W symulatorze czcionki są przechowywane jako tablica bajtów, w~których kolejne bity to kolejne piksele w~poziomie; dla kolejnych wierszy. W~tej sytuacji pobranie danego piksela wymaga najpierw wyliczenia numeru bajtu, potem numeru bitu w~bajcie. Wymaga to więc wyliczenia reszty z~dzielenia z~liczby, a~użyty mikrokontroler nie ma instrukcji służących do dzielenia, jest ono więc składane z~innych instrukcji i~trwa przez to znacznie dłużej. W~tej implementacji przy nanoszeniu znaku, zawsze adres aktualnie przenoszonego piksela znajdował się w~zmiennych. Zamiana tych zmiennych miejscami oznaczała transpozycję, anulowanie przenoszenia dla wartości z~pewnego przedziału oznaczało przycięcie; odjęcie wartości tych zmiennych od rozmiaru czcionki było przerzuceniem w~pionie bądź poziomie.

Jako, że przenoszenie po pikselu okazało się za mało wydajne, zostały wykonane różne inne operacje. Warto tutaj zwrócić uwagę na to, że bufor obrazu, na którym nanoszone są znaki jest jednowymiarową tablicą szesnastobitowych słów. Kolejne słowa oznaczają kolejne kolumny matrycy.

\subsubsection*{Zmiana zapisu czcionek}
Podstawową zmianą, była zmiana zapisu czcionek, dopasowanie do formatu ekranu. Zostały również zapisana jako kolejne słowa będące kolumnami. Również czcionka o~rozmiarze 8 pikseli, w~której jeden znak mógłby być zapisany na 8 bajtach, została zapisana na 8 słowach. Pamięć programu okazała się wystarczająco duża, żeby można było wykorzystać ją w~sposób nadmiarowy. Ta zmiana spowodowała, że naniesienie jednego znaku o~rozmiarze 16 pikseli zamiast 256 operacji na bitach, w~tym dzielenia; została zredukowana do 16 prostszych operacji. Wystarczy wykonać bitową operację LUB kolumny znaku z~kolumną bufora. Można też wykonać inne operacje logiczne dla całych kolumn uzyskując inne tryby nakładania znaku na bufor.

\subsubsection*{Implementacja przekształceń}
Przez tą zmianę piksele w~pionie nie są już jawnie adresowane, nie można w~prosty sposób ich porównać z~jakąś wartością, nałożyć przesunięcia. Obsługa zmian w~poziomie jest podobna do pierwotnej, z~tą różnicą, że zamiast wielokrotnego sprawdzania czy zmienna jest w~przedziale przy wycięciach, zastosowano maskę bitową.

Ustawianie pozycji w~pionie zostało zrealizowane jako przesunięcie bitowe pobranego słowa. Przesunięcie bitowe w~górę oznacza opuszczenie litery, ponieważ piksele odpowiadające bardziej znaczącym bitom są na dole. 

Przycięcie litery jest zaimplementowane przez iloczyn logiczny z~maską. Maska jest tworzona w~kilku operacjach, w~których z~bajtu z~ustawionymi wszystkimi bitami, przez przesunięcie bitowe w~jedną stronę i~z~powrotem zeruje się pewną liczbę bitów od tej strony.

Przerzucenie w~pionie jest zaimplementowane przy użyciu zamiany kolejności bitów w~słowie. Wykorzystano metodę, która przy użyciu kilku operacji logicznych zamienia kolejność najpierw sąsiednich bitów, potem par bitów, czwórek bitów i~całych bajtów. Jest to metoda powszechnie znana jako odpowiednia dla względnie długich ciągów bitów \cite{reverse-bits}. Jej kod znajduje się poniżej.

\begin{verbatim}
int16_t reverseBits(uint16_t v) {
    v = ((v >> 1) & 0x5555) | ((v & 0x5555) << 1);
    v = ((v >> 2) & 0x3333) | ((v & 0x3333) << 2);
    v = ((v >> 4) & 0x0F0F) | ((v & 0x0F0F) << 4);
    v = ((v >> 8) & 0x00FF) | ((v & 0x00FF) << 8);
    return v;
}
\end{verbatim}

Ciekawym zagadnieniem wydawało się zaimplementowanie szybkiej transpozycji. Ostatecznie została wybrana bardzo prosta metoda. Również w~tym wypadku zdecydowano się na pewne marnotrawstwo pamięci programu, czyli czcionki zostały zapisane dwukrotnie, standardowe i~transponowane. Transpozycja wybiera tylko skąd będą pobierane kolejne kolumny znaku.
